from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    List,
    Optional,
    Type,
    TypeVar,
    get_args,
    get_origin,
    get_type_hints,
)
from uuid import uuid4

from pydantic import BaseModel, Field


class Fragment(BaseModel):
    """
    A class representing a fragment of document/media.
    """

    id: str = Field(
        default_factory=lambda: str(uuid4()),
        description="Unique identifier for the fragment.",
    )
    label: str = Field(..., description="Label for the fragment.")
    metadata: Dict[str, Any] = Field(
        ..., description="Metadata associated with the fragment."
    )


class Document(Fragment):
    pass


class SearchDocument(Fragment):
    pass


class Operation(BaseModel):
    """
    A class representing an operation to be performed on one or more fragments and
    generating one or more new fragments
    """

    id: str = Field(
        default_factory=lambda: str(uuid4()),
        description="Unique identifier for the operation.",
    )
    name: str = Field(..., description="Type of the operation.")
    parameters: List[Fragment] = Field(..., description="Parameters for the operation.")
    results: List[Fragment] = Field(
        ..., description="List of fragments generated by the operation."
    )

    def __init__(self, **kwargs):
        """
        Initialize the Operation instance.
        """
        if not kwargs.get("id"):
            kwargs["id"] = str(uuid4())
        super().__init__(**kwargs)


#
# Operations
#

CommandFunctionType = TypeVar("CommandFunctionType", bound=Callable[..., Any])


class FragmentSpec(BaseModel, frozen=True):
    """
    A class representing a fragment specification.
    """

    fragment_type: type[Fragment] = Field(
        ..., description="Type of the input parameter."
    )
    label: str | None = Field(
        default = None,
        description="Label for the output parameter.", 
    )

    def __str__(self):
        result = f"{self.fragment_type.__name__}"
        if self.label:
            result += f"_{self.label}"
        return result

class OperationInput(BaseModel):
    """
    A class representing the input to an operation function.
    """

    name: str = Field(..., description="Name of the input parameter.")
    fragment_type: type[Fragment] = Field(
        ..., description="Type of the input parameter."
    )
    filter: Dict[str, Any] = Field(..., description="Filter for the input parameter.")

    def specs(self) -> list[FragmentSpec]:
        """
        Convert the OperationInput to a list of FragmentSpec.
        """
        if not self.filter:
            return [FragmentSpec(fragment_type=self.fragment_type)]
        elif isinstance(self.filter, dict):
            label_filters = self.filter.get("label")
            if label_filters is None:
                raise ValueError("Filter must contain a 'label' key.")

            if isinstance(label_filters, str):
                label_filters = [label_filters]
            return [
                FragmentSpec(
                    fragment_type=self.fragment_type,
                    label=label,
                )
                for label in label_filters
            ]
        else:
            raise ValueError("Filter must be a dictionary.")


class OperationOutput(BaseModel):
    """
    A class representing the output of an operation function.
    """

    fragment_type: type[Fragment] = Field(
        ..., description="Type of the input parameter."
    )
    multiple: bool = Field(..., description="Whether the output parameter is multiple.")
    label: str | None = Field(..., description="Label for the output parameter.")

    def spec(self) -> FragmentSpec:
        """
        Convert the OperationOutput to a FragmentSpec.
        """
        return FragmentSpec(
            fragment_type=self.fragment_type,
            label=self.label,
        )


class OperationInfo(BaseModel):
    """
    A class representing a operation function.
    """

    name: str = Field(..., description="Name of the operation function.")
    input: OperationInput
    output: OperationOutput
    func: CommandFunctionType = Field(..., description="The operation function.")

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)
